<application>
  <component name="AppStorage">
    <histories>
      <item value="The minimum radix available for conversion to and from strings. * The constant value of this field is the smallest value permitted * for the radix argument in radix-conversion methods such as the * {@code digit} method, the {@code forDigit} method, and the * {@code toString} method of class {@code Integer}." />
      <item value="If ArrayLists were immutable, or structurally immutable (no * adds, removes, etc), we could implement their spliterators * with Arrays.spliterator. Instead we detect as much * interference during traversal as practical without * sacrificing much performance. We rely primarily on * modCounts. These are not guaranteed to detect concurrency * violations, and are sometimes overly conservative about * within-thread interference, but detect enough problems to * be worthwhile in practice. To carry this out, we (1) lazily * initialize fence and expectedModCount until the latest * point that we need to commit to the state we are checking * against; thus improving precision. (This doesn't apply to * SubLists, that create spliterators with current non-lazy * values). (2) We perform only a single * ConcurrentModificationException check at the end of forEach * (the most performance-sensitive method). When using forEach * (as opposed to iterators), we can normally only detect * interference after actions, not before. Further * CME-triggering checks apply to all other possible * violations of assumptions for example null or too-small * elementData array given its size(), that could only have * occurred due to interference. This allows the inner loop * of forEach to run without any further checks, and * simplifies lambda-resolution. While this does entail a * number of checks, note that in the common case of * list.stream().forEach(a), no checks or other computation * occur anywhere other than inside forEach itself. The other * less-often-used methods cannot take advantage of most of * these streamlinings." />
      <item value="Internal" />
      <item value="ensure" />
      <item value="determine" />
      <item value="Candidate" />
      <item value="Determine the raw name, resolving aliases to canonical names." />
      <item value="Determine" />
      <item value="canonical" />
      <item value="* Determine whether the specified dependent bean has been registered as * dependent on the given bean or on any of its transitive dependencies." />
      <item value="Dependent" />
      <item value="Guarantee" />
      <item value="Fail if we're already creating this bean instance: // We're assumably within a circular reference." />
      <item value="Cache of singleton objects: bean name to bean instance" />
      <item value="This implementation performs an actual refresh of this context's underlying * bean factory, shutting down the previous bean factory (if any) and * initializing a fresh bean factory for the next phase of the context's lifecycle" />
      <item value="indicates" />
      <item value="Flag that indicates whether this context has been closed already." />
      <item value="Prepare this context for refreshing" />
      <item value="does not contain an ADD or COPY directive to include assembly created at maven" />
      <item value="Ambiguous" />
      <item value="hint" />
      <item value="priority" />
      <item value="INFRASTRUCTURE" />
      <item value="relevance" />
      <item value="has no relevance to the end-user" />
      <item value="entirely" />
      <item value="indicating" />
      <item value="candidate" />
      <item value="eligible" />
      <item value="Priority" />
      <item value="Instantiate" />
      <item value="Processor" />
      <item value="period" />
      <item value="constraints" />
      <item value="Mutex" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="34" />
        <entry key="ENGLISH" value="35" />
      </map>
    </option>
  </component>
</application>